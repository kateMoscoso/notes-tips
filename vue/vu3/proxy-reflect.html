<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Proxy and Reflect | Hello ;)</title>
    <meta name="description" content="Just playing around">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/notes-tips/assets/css/0.styles.d0e609a8.css" as="style"><link rel="preload" href="/notes-tips/assets/js/app.557ce569.js" as="script"><link rel="preload" href="/notes-tips/assets/js/2.d0218362.js" as="script"><link rel="preload" href="/notes-tips/assets/js/23.62dfaa37.js" as="script"><link rel="prefetch" href="/notes-tips/assets/js/10.5b08dcb9.js"><link rel="prefetch" href="/notes-tips/assets/js/11.43ade1ee.js"><link rel="prefetch" href="/notes-tips/assets/js/12.f8bc895e.js"><link rel="prefetch" href="/notes-tips/assets/js/13.24d9da50.js"><link rel="prefetch" href="/notes-tips/assets/js/14.251b784d.js"><link rel="prefetch" href="/notes-tips/assets/js/15.70e2dcbb.js"><link rel="prefetch" href="/notes-tips/assets/js/16.a770eeac.js"><link rel="prefetch" href="/notes-tips/assets/js/17.ec392fa7.js"><link rel="prefetch" href="/notes-tips/assets/js/18.6ad3cce7.js"><link rel="prefetch" href="/notes-tips/assets/js/19.c437d1ea.js"><link rel="prefetch" href="/notes-tips/assets/js/20.3818af9a.js"><link rel="prefetch" href="/notes-tips/assets/js/21.c71aa5ff.js"><link rel="prefetch" href="/notes-tips/assets/js/22.3fdbb1e5.js"><link rel="prefetch" href="/notes-tips/assets/js/24.5fac8cff.js"><link rel="prefetch" href="/notes-tips/assets/js/25.2cf37cc2.js"><link rel="prefetch" href="/notes-tips/assets/js/26.52485140.js"><link rel="prefetch" href="/notes-tips/assets/js/27.636c97a8.js"><link rel="prefetch" href="/notes-tips/assets/js/28.a0f23262.js"><link rel="prefetch" href="/notes-tips/assets/js/3.570f6e99.js"><link rel="prefetch" href="/notes-tips/assets/js/4.b9e1cdb8.js"><link rel="prefetch" href="/notes-tips/assets/js/5.74eeff93.js"><link rel="prefetch" href="/notes-tips/assets/js/6.095a5b90.js"><link rel="prefetch" href="/notes-tips/assets/js/7.fc4a63bc.js"><link rel="prefetch" href="/notes-tips/assets/js/8.75653bce.js"><link rel="prefetch" href="/notes-tips/assets/js/9.62c92631.js">
    <link rel="stylesheet" href="/notes-tips/assets/css/0.styles.d0e609a8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes-tips/" class="home-link router-link-active"><!----> <span class="site-name">Hello ;)</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes-tips/" class="nav-link">
  Init
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes-tips/" class="nav-link">
  Init
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/notes-tips/" class="sidebar-link">Tips documentation</a></li><li><a href="/notes-tips/javascript/" class="sidebar-link">Javascript</a></li><li><a href="/notes-tips/vue/" class="sidebar-link">Vue</a></li><li><a href="/notes-tips/docker/" class="sidebar-link">Docker</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="proxy-and-reflect"><a href="#proxy-and-reflect" class="header-anchor">#</a> Proxy and Reflect</h3> <p>Hooking onto Get and Set
We need a way to hook (or listen for) the get and set methods on our reactive objects.</p> <p><strong>GET property =&gt; We need to <code>track</code> the current effect</strong></p> <p><strong>SET property =&gt; We need to <code>trigger</code> any tracked dependencies (effects) for this property</strong></p> <p>The first step to understanding how to do this, is to understand how in Vue 3 with ES6 <code>Reflect</code> and <code>Proxy</code> we can intercept GET and SET calls. Previously in Vue 2 we did this with ES5 <code>Object.defineProperty</code>.</p> <h3 id="understanding-es6-reflect"><a href="#understanding-es6-reflect" class="header-anchor">#</a> Understanding ES6 Reflect</h3> <p>To print out an object property I can do this:</p> <div class="language- extra-class"><pre class="language-text"><code>let product = { price: 5, quantity: 2 }
console.log('quantity is ' + product.quantity)
// or 
console.log('quantity is ' + product['quantity'])
</code></pre></div><p>However, I can also GET values on an object by using <code>Reflect</code>. <code>Reflect</code> allows you to get a property on an object. It’s just another way to do what I wrote above:</p> <div class="language- extra-class"><pre class="language-text"><code>console.log('quantity is ' + Reflect.get(product, 'quantity'))
</code></pre></div><h3 id="understanding-es6-proxy"><a href="#understanding-es6-proxy" class="header-anchor">#</a> Understanding ES6 Proxy</h3> <p>A Proxy is a placeholder for another object, which by default delegates to the object. So if I run the following code:</p> <div class="language- extra-class"><pre class="language-text"><code>let product = { price: 5, quantity: 2 }
let proxiedProduct = new Proxy(product, {})
console.log(proxiedProduct.quantity)
</code></pre></div><p>The <code>proxiedProduct</code> delegates to the <code>product</code> which returns <code>2</code> as the quantity. Notice the second argument on Proxy with {}? This is called a handler and can be used to define custom behavior on the proxy object, like intercepting get and set calls. These interceptor methods are called traps and here’s how we would set a get trap on our handler:</p> <p>let product = { price: 5, quantity: 2 }</p> <p>let proxiedProduct = new Proxy(product, {
get() {
console.log('Get was called')
return 'Not the value'
}
})</p> <p>console.log(proxiedProduct.quantity)
In the console I’d see:</p> <p>Get was called</p> <p>Not the value</p> <p>We’ve re-written what get returns when the property value is accessed. We should probably return the actual value, which we can do like:</p> <p>let product = { price: 5, quantity: 2 }</p> <p>let proxiedProduct = new Proxy(product, {
get(target, key) {  // &lt;--- The target (our object) and key (the property name)
console.log('Get was called with key = ' + key)
return target[key]
}
})</p> <p>console.log(proxiedProduct.quantity)
Notice that the get function has two parameters, both the target which is our object (product) and the key we are trying to get, which in this case is quantity. Now we see:</p> <p>Get was called with key = quantity</p> <p>2</p> <p>This is also where we can use Reflect and add an additional argument to it.</p> <p>let product = { price: 5, quantity: 2 }
let proxiedProduct = new Proxy(product, {
get(target, key, receiver) {  // &lt;--- notice the receiver
console.log('Get was called with key = ' + key)
return Reflect.get(target, key, receiver) // &lt;----
}
})
Notice our get has an additional parameter called receiver which we’re sending as an argument into Reflect.get. This ensures that the proper value of this is used when our object has inherited values / functions from another object. This is why we always use Reflect inside of a Proxy, so we can keep the original behavior we are customizing.</p> <p>Now let’s add a setter method, there shouldn’t be any big surprises here:</p> <p>let product = { price: 5, quantity: 2 }</p> <p>let proxiedProduct = new Proxy(product, {
get(target, key, receiver) {<br>
console.log('Get was called with key = ' + key)
return Reflect.get(target, key, receiver)
}
set(target, key, value, receiver) {
console.log('Set was called with key = ' + key + ' and value = ' + value)
return Reflect.set(target, key, value, receiver)
}
})</p> <p>proxiedProduct.quantity = 4
console.log(proxiedProduct.quantity)
Notice that set looks very similar to get except that it’s using Reflect.set which receives the value to set the target (product). Our output as expected is:</p> <p>Set was called with key = quantity and value = 4</p> <p>Get was called with key = quantity</p> <p>4</p> <p>There’s another way we can encapsulate this code, which is what you see in the Vue 3 source code. First, we’ll wrap this proxying code in a reactive function which returns the proxy, which should look familiar if you’ve played with the Vue 3 Composition API. Then we’ll declare our handler with it’s traps separately and send them into our proxy.</p> <p>function reactive(target) {
const handler = {
get(target, key, receiver) {
console.log('Get was called with key = ' + key)
return Reflect.get(target, key, receiver)
},
set(target, key, value, receiver) {
console.log('Set was called with key = ' + key + ' and value = ' + value)
return Reflect.set(target, key, value, receiver)
}
}
return new Proxy(target, handler)
}</p> <p>let product = reactive({ price: 5, quantity: 2 }) // &lt;-- Returns a proxy object
product.quantity = 4
console.log(product.quantity)
This would return the same as above, but now we can easily create multiple reactive objects.</p> <p>Combining Proxy + Effect Storage
If we take the code we have for creating reactive objects, and remember:</p> <p>GET property =&gt; We need to track the current effect</p> <p>SET property =&gt; We need to trigger any tracked dependencies (effects) for this property</p> <p>We can start to imagine where we need to call track and trigger with the code above:</p> <p>function reactive(target) {
const handler = {
get(target, key, receiver) {
let result = Reflect.get(target, key, receiver)
// Track
return result
},
set(target, key, value, receiver) {
let oldValue = target[key]
let result = Reflect.set(target, key, value, receiver)
if (oldValue != result) { // Only if the value changes
// Trigger
}
return result
}
}
return new Proxy(target, handler)
}
Now let’s put the two pieces of code together:</p> <p>const targetMap = new WeakMap() // targetMap stores the effects that each object should re-run when it's updated
function track(target, key) {
// We need to make sure this effect is being tracked.
let depsMap = targetMap.get(target) // Get the current depsMap for this target
if (!depsMap) {
// There is no map.
targetMap.set(target, (depsMap = new Map())) // Create one
}
let dep = depsMap.get(key) // Get the current dependencies (effects) that need to be run when this is set
if (!dep) {
// There is no dependencies (effects)
depsMap.set(key, (dep = new Set())) // Create a new Set
}
dep.add(effect) // Add effect to dependency map
}
function trigger(target, key) {
const depsMap = targetMap.get(target) // Does this object have any properties that have dependencies (effects)
if (!depsMap) {
return
}
let dep = depsMap.get(key) // If there are dependencies (effects) associated with this
if (dep) {
dep.forEach(effect =&gt; {
// run them all
effect()
})
}
}</p> <p>function reactive(target) {
const handler = {
get(target, key, receiver) {
let result = Reflect.get(target, key, receiver)
track(target, key) // If this reactive property (target) is GET inside then track the effect to rerun on SET
return result
},
set(target, key, value, receiver) {
let oldValue = target[key]
let result = Reflect.set(target, key, value, receiver)
if (oldValue != result) {
trigger(target, key) // If this reactive property (target) has effects to rerun on SET, trigger them.
}
return result
}
}
return new Proxy(target, handler)
}</p> <p>let product = reactive({ price: 5, quantity: 2 })
let total = 0</p> <p>let effect = () =&gt; {
total = product.price * product.quantity
}
effect()</p> <p>console.log('before updated quantity total = ' + total)
product.quantity = 3
console.log('after updated quantity total = ' + total)
Notice how we no longer need to call trigger and track because these are getting properly called inside our get and set methods. Running this code gives us:</p> <p>before updated quantity total = 10</p> <p>after updated quantity total = 15</p> <p>Wow, we’ve come a long way! There’s only one bug to fix before this code is solid. Specifically, that we only want track to be called on a reactive object if it’s inside an effect. Right now track will be called whenever a reactive object property is get. We’ll polish this up in the next lesson.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/notes-tips/assets/js/app.557ce569.js" defer></script><script src="/notes-tips/assets/js/2.d0218362.js" defer></script><script src="/notes-tips/assets/js/23.62dfaa37.js" defer></script>
  </body>
</html>
