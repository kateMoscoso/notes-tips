(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{371:function(e,t,r){"use strict";r.r(t);var n=r(43),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"proxy-and-reflect"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-and-reflect"}},[e._v("#")]),e._v(" Proxy and Reflect")]),e._v(" "),r("p",[e._v("Hooking onto Get and Set\nWe need a way to hook (or listen for) the get and set methods on our reactive objects.")]),e._v(" "),r("p",[r("strong",[e._v("GET property => We need to "),r("code",[e._v("track")]),e._v(" the current effect")])]),e._v(" "),r("p",[r("strong",[e._v("SET property => We need to "),r("code",[e._v("trigger")]),e._v(" any tracked dependencies (effects) for this property")])]),e._v(" "),r("p",[e._v("The first step to understanding how to do this, is to understand how in Vue 3 with ES6 "),r("code",[e._v("Reflect")]),e._v(" and "),r("code",[e._v("Proxy")]),e._v(" we can intercept GET and SET calls. Previously in Vue 2 we did this with ES5 "),r("code",[e._v("Object.defineProperty")]),e._v(".")]),e._v(" "),r("h3",{attrs:{id:"understanding-es6-reflect"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#understanding-es6-reflect"}},[e._v("#")]),e._v(" Understanding ES6 Reflect")]),e._v(" "),r("p",[e._v("To print out an object property I can do this:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let product = { price: 5, quantity: 2 }\nconsole.log('quantity is ' + product.quantity)\n// or \nconsole.log('quantity is ' + product['quantity'])\n")])])]),r("p",[e._v("However, I can also GET values on an object by using "),r("code",[e._v("Reflect")]),e._v(". "),r("code",[e._v("Reflect")]),e._v(" allows you to get a property on an object. It’s just another way to do what I wrote above:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("console.log('quantity is ' + Reflect.get(product, 'quantity'))\n")])])]),r("h3",{attrs:{id:"understanding-es6-proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#understanding-es6-proxy"}},[e._v("#")]),e._v(" Understanding ES6 Proxy")]),e._v(" "),r("p",[e._v("A Proxy is a placeholder for another object, which by default delegates to the object. So if I run the following code:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let product = { price: 5, quantity: 2 }\nlet proxiedProduct = new Proxy(product, {})\nconsole.log(proxiedProduct.quantity)\n")])])]),r("p",[e._v("The "),r("code",[e._v("proxiedProduct")]),e._v(" delegates to the "),r("code",[e._v("product")]),e._v(" which returns "),r("code",[e._v("2")]),e._v(" as the quantity. Notice the second argument on Proxy with {}? This is called a handler and can be used to define custom behavior on the proxy object, like intercepting get and set calls. These interceptor methods are called traps and here’s how we would set a get trap on our handler:")]),e._v(" "),r("p",[e._v("let product = { price: 5, quantity: 2 }")]),e._v(" "),r("p",[e._v("let proxiedProduct = new Proxy(product, {\nget() {\nconsole.log('Get was called')\nreturn 'Not the value'\n}\n})")]),e._v(" "),r("p",[e._v("console.log(proxiedProduct.quantity)\nIn the console I’d see:")]),e._v(" "),r("p",[e._v("Get was called")]),e._v(" "),r("p",[e._v("Not the value")]),e._v(" "),r("p",[e._v("We’ve re-written what get returns when the property value is accessed. We should probably return the actual value, which we can do like:")]),e._v(" "),r("p",[e._v("let product = { price: 5, quantity: 2 }")]),e._v(" "),r("p",[e._v("let proxiedProduct = new Proxy(product, {\nget(target, key) {  // <--- The target (our object) and key (the property name)\nconsole.log('Get was called with key = ' + key)\nreturn target[key]\n}\n})")]),e._v(" "),r("p",[e._v("console.log(proxiedProduct.quantity)\nNotice that the get function has two parameters, both the target which is our object (product) and the key we are trying to get, which in this case is quantity. Now we see:")]),e._v(" "),r("p",[e._v("Get was called with key = quantity")]),e._v(" "),r("p",[e._v("2")]),e._v(" "),r("p",[e._v("This is also where we can use Reflect and add an additional argument to it.")]),e._v(" "),r("p",[e._v("let product = { price: 5, quantity: 2 }\nlet proxiedProduct = new Proxy(product, {\nget(target, key, receiver) {  // <--- notice the receiver\nconsole.log('Get was called with key = ' + key)\nreturn Reflect.get(target, key, receiver) // <----\n}\n})\nNotice our get has an additional parameter called receiver which we’re sending as an argument into Reflect.get. This ensures that the proper value of this is used when our object has inherited values / functions from another object. This is why we always use Reflect inside of a Proxy, so we can keep the original behavior we are customizing.")]),e._v(" "),r("p",[e._v("Now let’s add a setter method, there shouldn’t be any big surprises here:")]),e._v(" "),r("p",[e._v("let product = { price: 5, quantity: 2 }")]),e._v(" "),r("p",[e._v("let proxiedProduct = new Proxy(product, {\nget(target, key, receiver) {"),r("br"),e._v("\nconsole.log('Get was called with key = ' + key)\nreturn Reflect.get(target, key, receiver)\n}\nset(target, key, value, receiver) {\nconsole.log('Set was called with key = ' + key + ' and value = ' + value)\nreturn Reflect.set(target, key, value, receiver)\n}\n})")]),e._v(" "),r("p",[e._v("proxiedProduct.quantity = 4\nconsole.log(proxiedProduct.quantity)\nNotice that set looks very similar to get except that it’s using Reflect.set which receives the value to set the target (product). Our output as expected is:")]),e._v(" "),r("p",[e._v("Set was called with key = quantity and value = 4")]),e._v(" "),r("p",[e._v("Get was called with key = quantity")]),e._v(" "),r("p",[e._v("4")]),e._v(" "),r("p",[e._v("There’s another way we can encapsulate this code, which is what you see in the Vue 3 source code. First, we’ll wrap this proxying code in a reactive function which returns the proxy, which should look familiar if you’ve played with the Vue 3 Composition API. Then we’ll declare our handler with it’s traps separately and send them into our proxy.")]),e._v(" "),r("p",[e._v("function reactive(target) {\nconst handler = {\nget(target, key, receiver) {\nconsole.log('Get was called with key = ' + key)\nreturn Reflect.get(target, key, receiver)\n},\nset(target, key, value, receiver) {\nconsole.log('Set was called with key = ' + key + ' and value = ' + value)\nreturn Reflect.set(target, key, value, receiver)\n}\n}\nreturn new Proxy(target, handler)\n}")]),e._v(" "),r("p",[e._v("let product = reactive({ price: 5, quantity: 2 }) // <-- Returns a proxy object\nproduct.quantity = 4\nconsole.log(product.quantity)\nThis would return the same as above, but now we can easily create multiple reactive objects.")]),e._v(" "),r("p",[e._v("Combining Proxy + Effect Storage\nIf we take the code we have for creating reactive objects, and remember:")]),e._v(" "),r("p",[e._v("GET property => We need to track the current effect")]),e._v(" "),r("p",[e._v("SET property => We need to trigger any tracked dependencies (effects) for this property")]),e._v(" "),r("p",[e._v("We can start to imagine where we need to call track and trigger with the code above:")]),e._v(" "),r("p",[e._v("function reactive(target) {\nconst handler = {\nget(target, key, receiver) {\nlet result = Reflect.get(target, key, receiver)\n// Track\nreturn result\n},\nset(target, key, value, receiver) {\nlet oldValue = target[key]\nlet result = Reflect.set(target, key, value, receiver)\nif (oldValue != result) { // Only if the value changes\n// Trigger\n}\nreturn result\n}\n}\nreturn new Proxy(target, handler)\n}\nNow let’s put the two pieces of code together:")]),e._v(" "),r("p",[e._v("const targetMap = new WeakMap() // targetMap stores the effects that each object should re-run when it's updated\nfunction track(target, key) {\n// We need to make sure this effect is being tracked.\nlet depsMap = targetMap.get(target) // Get the current depsMap for this target\nif (!depsMap) {\n// There is no map.\ntargetMap.set(target, (depsMap = new Map())) // Create one\n}\nlet dep = depsMap.get(key) // Get the current dependencies (effects) that need to be run when this is set\nif (!dep) {\n// There is no dependencies (effects)\ndepsMap.set(key, (dep = new Set())) // Create a new Set\n}\ndep.add(effect) // Add effect to dependency map\n}\nfunction trigger(target, key) {\nconst depsMap = targetMap.get(target) // Does this object have any properties that have dependencies (effects)\nif (!depsMap) {\nreturn\n}\nlet dep = depsMap.get(key) // If there are dependencies (effects) associated with this\nif (dep) {\ndep.forEach(effect => {\n// run them all\neffect()\n})\n}\n}")]),e._v(" "),r("p",[e._v("function reactive(target) {\nconst handler = {\nget(target, key, receiver) {\nlet result = Reflect.get(target, key, receiver)\ntrack(target, key) // If this reactive property (target) is GET inside then track the effect to rerun on SET\nreturn result\n},\nset(target, key, value, receiver) {\nlet oldValue = target[key]\nlet result = Reflect.set(target, key, value, receiver)\nif (oldValue != result) {\ntrigger(target, key) // If this reactive property (target) has effects to rerun on SET, trigger them.\n}\nreturn result\n}\n}\nreturn new Proxy(target, handler)\n}")]),e._v(" "),r("p",[e._v("let product = reactive({ price: 5, quantity: 2 })\nlet total = 0")]),e._v(" "),r("p",[e._v("let effect = () => {\ntotal = product.price * product.quantity\n}\neffect()")]),e._v(" "),r("p",[e._v("console.log('before updated quantity total = ' + total)\nproduct.quantity = 3\nconsole.log('after updated quantity total = ' + total)\nNotice how we no longer need to call trigger and track because these are getting properly called inside our get and set methods. Running this code gives us:")]),e._v(" "),r("p",[e._v("before updated quantity total = 10")]),e._v(" "),r("p",[e._v("after updated quantity total = 15")]),e._v(" "),r("p",[e._v("Wow, we’ve come a long way! There’s only one bug to fix before this code is solid. Specifically, that we only want track to be called on a reactive object if it’s inside an effect. Right now track will be called whenever a reactive object property is get. We’ll polish this up in the next lesson.")])])}),[],!1,null,null,null);t.default=a.exports}}]);