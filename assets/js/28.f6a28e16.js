(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{375:function(e,t,n){"use strict";n.r(t);var a=n(43),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Build a Reactivity System\nIn this lesson we will build a simple reactivity system using the very same techniques you’ll find in the Vue source code. This will give you a better understanding of Vue.js and it’s design patterns, as well as get you familiar with watchers and the Dep class.")]),e._v(" "),n("p",[e._v("The Reactivity System\nVue’s reactivity system can look like magic when you see it working for the first time.")]),e._v(" "),n("p",[e._v("Take this simple app:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('<div id="app">\n  <div>Price: $'+e._s(e.price)+"</div>\n  <div>Total: $"+e._s(e.price*e.quantity)+"</div>\n  <div>Taxes: $"+e._s(e.totalPriceWithTax)+"</div>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"><\/script>\n<script>\n  var vm = new Vue({\n    el: '#app',\n    data: {\n      price: 5.00,\n      quantity: 2\n    },\n    computed: {\n      totalPriceWithTax() {\n        return this.price * this.quantity * 1.03\n      }\n    }\n  })\n<\/script>\n")])])]),n("p",[e._v("And somehow Vue just knows that if price changes, it should do three things:")]),e._v(" "),n("p",[e._v("Update the price value on our webpage.\nRecalculate the expression that multiplies price * quantity, and update the page.\nCall the totalPriceWithTax function again and update the page.\nBut wait, I hear you wonder, how does Vue know what to update when the price changes, and how does it keep track of everything?")]),e._v(" "),n("p",[e._v("This is not how JavaScript programming usually works")]),e._v(" "),n("p",[e._v("If it’s not obvious to you, the big problem we have to address is that programming usually doesn’t work this way. For example, if I run this code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let price = 5\nlet quantity = 2\nlet total = price * quantity  // 10 right?\nprice = 20\nconsole.log(`total is ${total}`)\n")])])]),n("p",[e._v("What do you think it’s going to print? Since we’re not using Vue, it’s going to print 10.")]),e._v(" "),n("blockquote",[n("blockquote",[n("p",[e._v("total is 10\nIn Vue we want total to get updated whenever price or quantity get updated. We want:")])])]),e._v(" "),n("blockquote",[n("blockquote",[n("p",[e._v("total is 40\nUnfortunately, JavaScript is procedural, not reactive, so this doesn’t work in real life. In order to make total reactive, we have to use JavaScript to make things behave differently.")])])]),e._v(" "),n("p",[e._v("Problem\nWe need to save how we’re calculating the total, so we can re-run it when price or quantity changes.")]),e._v(" "),n("p",[e._v("Solution\nFirst off, we need some way to tell our application, “The code I’m about to run, store this, I may need you to run it at another time.” Then we’ll want to run the code, and if price or quantity variables get updated, run the stored code again.")]),e._v(" "),n("p",[e._v("We might do this by recording the function so we can run it again.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let price = 5\nlet quantity = 2\nlet total = 0\nlet target = null\n\ntarget = function () { \n  total = price * quantity\n}\n\nrecord() // Remember this in case we want to run it later\ntarget() // Also go ahead and run it\n")])])]),n("p",[e._v("Notice that we store an anonymous function inside the target variable, and then call a record function. Using the ES6 arrow syntax I could also write this as:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("target = () => { total = price * quantity }\n")])])]),n("p",[e._v("The definition of the record is simply:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let storage = [] // We'll store our target functions in here\n\nfunction record () { // target = () => { total = price * quantity }\n  storage.push(target)\n}\n")])])]),n("p",[e._v("We’re storing the target (in our case the { total = price * quantity }) so we can run it later, perhaps with a replay function that runs all the things we’ve recorded.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function replay (){\n  storage.forEach(run => run())\n}\n")])])]),n("p",[e._v("This goes through all the anonymous functions we have stored inside the storage array and executes each of them.")]),e._v(" "),n("p",[e._v("Then in our code, we can just:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("price = 20\nconsole.log(total) // => 10\nreplay()\nconsole.log(total) // => 40\n")])])]),n("p",[e._v("Simple enough, right? Here’s the code in it’s entirety if you need to read through and try to grasp it one more time. FYI, I am coding this in a particular way, in case you’re wondering why.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let price = 5\nlet quantity = 2\nlet total = 0\nlet target = null\nlet storage = []\n\nfunction record () { \n  storage.push(target)\n}\n\nfunction replay () {\n  storage.forEach(run => run())\n}\n\ntarget = () => { total = price * quantity }\n\nrecord()\ntarget()\n\nprice = 20\nconsole.log(total) // => 10\nreplay()\nconsole.log(total) // => 40\n")])])]),n("p",[e._v("Problem\nWe could go on recording targets as needed, but it’d be nice to have a more robust solution that will scale with our app. Perhaps a class that takes care of maintaining a list of targets that get notified when we need them to get re-run.")]),e._v(" "),n("p",[e._v("Solution: A Dependency Class\nOne way we can begin to solve this problem is by encapsulating this behavior into its own class, a Dependency Class which implements the standard programming observer pattern.")]),e._v(" "),n("p",[e._v("So, if we create a JavaScript class to manage our dependencies (which is closer to how Vue handles things), it might look like this:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("class Dep { // Stands for dependency\n  constructor () {\n    this.subscribers = [] // The targets that are dependent, and should be \n                          // run when notify() is called.\n  }\n  depend() {  // This replaces our record function\n    if (target && !this.subscribers.includes(target)) {\n      // Only if there is a target & it's not already subscribed\n      this.subscribers.push(target)\n    } \n  }\n  notify() {  // Replaces our replay function\n    this.subscribers.forEach(sub => sub()) // Run our targets, or observers.\n  }\n}\n")])])]),n("p",[e._v("Notice instead of storage we’re now storing our anonymous functions in subscribers. ****Instead of our record function we now call depend ****and we now use notify instead of replay. To get this running:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("const dep = new Dep()\n\nlet price = 5\nlet quantity = 2\nlet total = 0\nlet target = () => { total = price * quantity }\ndep.depend() // Add this target to our subscribers\ntarget()  // Run it to get the total\n\nconsole.log(total) // => 10 .. The right number\nprice = 20\nconsole.log(total) // => 10 .. No longer the right number\ndep.notify()       // Run the subscribers \nconsole.log(total) // => 40  .. Now the right number\n")])])]),n("p",[e._v("It still works, and now our code feels more reusable. Only thing that still feels a little weird is the setting and running of the target.")]),e._v(" "),n("p",[e._v("Problem\nIn the future we’re going to have a Dep class for each variable, and it’ll be nice to encapsulate the behavior of creating anonymous functions that need to be watched for updates. Perhaps a watcher function might be in order to take care of this behavior.")]),e._v(" "),n("p",[e._v("So instead of calling:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("target = () => { total = price * quantity }\ndep.depend() \ntarget() \n")])])]),n("p",[e._v("(this is just the code from above)")]),e._v(" "),n("p",[e._v("We can instead just call:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("watcher(() => {\n  total = price * quantity\n})\n")])])]),n("p",[e._v("Solution: A Watcher Function\nInside our Watcher fucntion we can do a few simple things:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function watcher(myFunc) {\n  target = myFunc // Set as the active target\n  dep.depend()       // Add the active target as a dependency\n  target()           // Call the target\n  target = null      // Reset the target\n}\n")])])]),n("p",[e._v("As you can see, the watcher function takes a myFunc argument, sets that as a our global target property, calls dep.depend() to add our target as a subscriber, calls the target function, and resets the target.")]),e._v(" "),n("p",[e._v("Now when we run the following:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("price = 20\nconsole.log(total)\ndep.notify()      \nconsole.log(total) \n")])])]),n("p",[e._v("You might be wondering why we implemented target as a global variable, rather than passing it into our functions where needed. There is a good reason for this, which will become obvious by the end of our article.")]),e._v(" "),n("p",[e._v("Problem\nWe have a single Dep class, but what we really want is each of our variables to have its own Dep. Let me move things into properties before we go any further.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let data = { price: 5, quantity: 2 }\n")])])]),n("p",[e._v("Let’s assume for a minute that each of our properties (price and quantity) have their own internal Dep class.")]),e._v(" "),n("p",[e._v("Now when we run:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("watcher(() => {\n  total = data.price * data.quantity\n})\n")])])]),n("p",[e._v("Since the data.price value is accessed (which it is), I want the price property’s Dep class to push our anonymous function (stored in target) onto its subscriber array (by calling dep.depend()). Since data.quantity is accessed I also want the quantity property Dep class to push this anonymous function (stored in target) into its subscriber array.")]),e._v(" "),n("p",[e._v("If I have another anonymous function where just data.price is accessed, I want that pushed just to the price property Dep class.")]),e._v(" "),n("p",[e._v("When do I want dep.notify() to be called on price’s subscribers? I want them to be called when price is set. By the end of the article I want to be able to go into the console and do:")]),e._v(" "),n("blockquote",[n("blockquote",[n("p",[e._v("total\n10")])]),e._v(" "),n("blockquote",[n("p",[e._v("price = 20  // When this gets run it will need to call notify() on the price\ntotal\n40\nWe need some way to hook into a data property (like price or quantity) so when it’s accessed we can save the target into our subscriber array, and when it’s changed run the functions stored our subscriber array.")])])]),e._v(" "),n("p",[e._v("Solution: Object.defineProperty()\nWe need to learn about the Object.defineProperty() function which is plain ES5 JavaScript. It allows us to define getter and setter functions for a property. Lemme show you the very basic usage, before I show you how we’re going to use it with our Dep class.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let data = { price: 5, quantity: 2 }\n\nObject.defineProperty(data, 'price', {  // For just the price property\n\n    get() {  // Create a get method\n      console.log(`I was accessed`)\n    },\n    \n    set(newVal) {  // Create a set method\n      console.log(`I was changed`)\n    }\n})\ndata.price // This calls get()\ndata.price = 20  // This calls set()\n")])])]),n("p",[e._v("As you can see, it just logs two lines. However, it doesn’t actually get or set any values, since we over-rode the functionality. Let’s add it back now. get() expects to return a value, and set() still needs to update a value, so let’s add an internalValue variable to store our current price value.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let data = { price: 5, quantity: 2 }\n\nlet internalValue = data.price // Our initial value.\n\nObject.defineProperty(data, 'price', {  // For just the price property\n\n    get() {  // Create a get method\n      console.log(`Getting price: ${internalValue}`)\n      return internalValue\n    },\n    \n    set(newVal) {  // Create a set method\n      console.log(`Setting price to: ${newVal}` )\n      internalValue = newVal\n    }\n})\ntotal = data.price * data.quantity  // This calls get() \ndata.price = 20  // This calls set()\n")])])]),n("p",[e._v("Now that our get and set are working properly, what do you think will print to the console?")]),e._v(" "),n("p",[e._v("So we have a way to get notified when we get and set values. And with some recursion we can run this for all items in our data array, right?")]),e._v(" "),n("p",[e._v("FYI, Object.keys(data) returns an array of the keys of the object.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let data = { price: 5, quantity: 2 }\n\nObject.keys(data).forEach(key => { // We're running this for each item in data now\n  let internalValue = data[key]\n  Object.defineProperty(data, key, {\n    get() {\n      console.log(`Getting ${key}: ${internalValue}`)\n      return internalValue\n    },\n    set(newVal) {\n      console.log(`Setting ${key} to: ${newVal}` )\n      internalValue = newVal\n    }\n  })\n})\ntotal = data.price * data.quantity\ndata.price = 20\n")])])]),n("p",[e._v("Now everything has getters and setters, and we see this on the console.")]),e._v(" "),n("p",[e._v("Putting both ideas together\ntotal = data.price * data.quantity\nWhen a piece of code like this gets run and gets the value of price, we want price to remember this anonymous function (target). That way if price gets changed, or is set to a new value, it’ll trigger this function to get rerun, since it knows this line is dependent upon it. So you can think of it like this.")]),e._v(" "),n("p",[e._v("Get => Remember this anonymous function, we’ll run it again when our value changes.")]),e._v(" "),n("p",[e._v("Set => Run the saved anonymous function, our value just changed.")]),e._v(" "),n("p",[e._v("Or in the case of our Dep Class")]),e._v(" "),n("p",[e._v("Price accessed (get) => call dep.depend() to save the current target")]),e._v(" "),n("p",[e._v("Price set => call dep.notify() on price, re-running all the targets")]),e._v(" "),n("p",[e._v("Let’s combine these two ideas, and walk through our final code.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let data = { price: 5, quantity: 2 }\nlet target = null\n\n// This is exactly the same Dep class\nclass Dep {\n  constructor () {\n    this.subscribers = [] \n  }\n  depend() {  \n    if (target && !this.subscribers.includes(target)) {\n      // Only if there is a target & it's not already subscribed\n      this.subscribers.push(target)\n    } \n  }\n  notify() {\n    this.subscribers.forEach(sub => sub())\n  }\n}\n\n// Go through each of our data properties\nObject.keys(data).forEach(key => {\n  let internalValue = data[key]\n  \n  // Each property gets a dependency instance\n  const dep = new Dep()\n  \n  Object.defineProperty(data, key, {\n    get() {\n      dep.depend() // <-- Remember the target we're running\n      return internalValue\n    },\n    set(newVal) {\n      internalValue = newVal\n      dep.notify() // <-- Re-run stored functions\n    }\n  })\n})\n\n// My watcher no longer calls dep.depend,\n// since that gets called from inside our get method.\nfunction watcher(myFunc) {\n  target = myFunc\n  target()\n  target = null\n}\n\nwatcher(() => {\n  data.total = data.price * data.quantity\n})\n")])])]),n("p",[e._v("And now look at what happens in our console when we play around.")]),e._v(" "),n("p",[e._v("Exactly what we were hoping for! Both price and quantity are indeed reactive! Our total code gets re-run whenever the value of price or quantity gets updated.")]),e._v(" "),n("p",[e._v("Jumping to Vue\nThis illustration from the Vue docs should start to make sense now.")]),e._v(" "),n("p",[e._v("Reactivity Cycle")]),e._v(" "),n("p",[e._v("Do you see that beautiful purple Data circle with the getters and setters? It should look familiar! Every component instance has a watcher instance (in blue) which collects dependencies from the getters (red line). When a setter is called later, it notifies the watcher which causes the component to re-render. Here’s the image again with some of my own annotations.")]),e._v(" "),n("p",[e._v("Yeah, doesn’t this make a whole lot more sense now?")]),e._v(" "),n("p",[e._v("Obviously how Vue does this under the covers is more complex, but you now know the basics. In the next lesson we’ll dive under the hood with Vue, and see if we can find this pattern inside the source code.")]),e._v(" "),n("p",[e._v("So what have we learned?\nHow to create a Dep class which collects a dependencies (depend) and re-runs all dependencies (notify).\nHow to create a watcher to manage the code we’re running, that may need to be added (target) as a dependency.\nHow to use Object.defineProperty() to create getters and setters.")]),e._v(" "),n("p",[e._v("What are the Advantages?\nThe proxy API allows us to create a virtual representation of an object and provides us with handlers like set(), get() and deleteProperty() etc that we can use to intercept when properties are accessed or modified on the original object. This relieves us from the following limitations:")]),e._v(" "),n("p",[e._v("Usage of Vue.$set() to add new reactive properties and Vue.$delete() to delete existing properties.\nArray change detection.\nOur Previous Code\nPreviously we used Object.defineProperty() to listen for when our properties are get and set. Here is a codepen which shows where we ended up on the last lesson:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('let data = { price: 5, quantity: 2 };\nlet target = null;\n\n// Our simple Dep class\nclass Dep {\n  constructor() {\n    this.subscribers = [];\n  }\n  depend() {\n    if (target && !this.subscribers.includes(target)) {\n      // Only if there is a target & it\'s not already subscribed\n      this.subscribers.push(target);\n    }\n  }\n  notify() {\n    this.subscribers.forEach(sub => sub());\n  }\n}\n\n// Go through each of our data properties\nObject.keys(data).forEach(key => {\n  let internalValue = data[key];\n\n  // Each property gets a dependency instance\n  const dep = new Dep();\n\n  Object.defineProperty(data, key, {\n    get() {\n      dep.depend(); // <-- Remember the target we\'re running\n      return internalValue;\n    },\n    set(newVal) {\n      internalValue = newVal;\n      dep.notify(); // <-- Re-run stored functions\n    }\n  });\n});\n\n// The code to watch to listen for reactive properties\nfunction watcher(myFunc) {\n  target = myFunc;\n  target();\n  target = null;\n}\n\nwatcher(() => {\n  data.total = data.price * data.quantity;\n});\n\nconsole.log("total = " + data.total)\ndata.price = 20\nconsole.log("total = " + data.total)\ndata.quantity = 10\nconsole.log("total = " + data.total)\n')])])]),n("p",[e._v("Solution: Using Proxy to overcome the limitations\nInstead of looping through each property to add getters/setters we can set up a proxy on our data object using:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("//data is our source object being observed\nconst observedData = new Proxy(data, { \n  get() {\n    //invoked when property from source data object is accessed\n  },\n  set() {\n    //invoked when property from source data object is modified\n  },\n  deleteProperty() {\n    //invoked when property from source data object is deleted\n  }\n});\n")])])]),n("p",[e._v("The second argument passed to Proxy constructor function is called the handler. Handler is nothing but an object that contains functions known as traps. These traps allow us to intercept operations happening on the source data object.")]),e._v(" "),n("p",[e._v("The get() and set() are two traps that can be used to invoke dep.depend() and dep.notify() respectively. The set() trap will be invoked even for the newly added properties, so it can be it can be used to make new properties reactive. Hence, we no longer need to declare new reactive properties using Vue.$set(). The same applies for deletion of reactive properties which can be handled in deleteProperty() trap.")]),e._v(" "),n("p",[e._v("Implementing the Reactivity System Using Proxies\nEven though the Proxy API is not yet incorporated into Vue’s reactivity system, let’s try to implement the reactivity system from the previous lesson using Proxy ourselves. The first thing we’ll change is our Object.keys(data).forEach loop, which we’ll now use to create a new Dep for each reactive property.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let deps = new Map(); // Let's store all of our data's deps in a map\nObject.keys(data).forEach(key => {\n  // Each property gets a dependency instance\n  deps.set(key, new Dep());\n});\n")])])]),n("p",[e._v("Side Note: The Dep class remains the same. Now we’ll replace the use of Object.defineProperty with the use of a proxy:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let data_without_proxy = data; // Save old data object\ndata = new Proxy(data_without_proxy, {\n  // Override data to have a proxy in the middle\n  get(obj, key) {\n    deps.get(key).depend(); // <-- Remember the target we're running\n    return obj[key]; // call original data\n  },\n  set(obj, key, newVal) {\n    obj[key] = newVal; // Set original data to new value\n    deps.get(key).notify(); // <-- Re-run stored functions\n    return true;\n  }\n});\n")])])]),n("p",[e._v("As you can see, we create a variable data_without_proxy that holds the copy of our source data object which will be used when overwriting the data object to have a Proxy object. The get() and set() traps are passed in as the properties to handler object which is the 2nd argument.")]),e._v(" "),n("p",[e._v("get(obj, key) This is the function that gets invoked when a property is accessed. It receives the original object i.e data_without_proxy as obj and the key of the property that is accessed. We call the depend() method of the specific Dep class associated to that particular property. At last the value related to that key is returned using return obj[key].")]),e._v(" "),n("p",[e._v("set(obj, key, newVal) The first two arguments are the same as the above-mentioned get() trap. The 3rd argument is the new modified value. Then we set the new value to the property that is modified using obj[key] = newVal and call the notify() method.")]),e._v(" "),n("p",[e._v("Moving Total & Testing\nWe need to make one more small change to our code. We need to extract total into its own variable as it does not need to be reactive.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('let total = 0;\nwatcher(() => {\n  total = data.price * data.quantity;\n});\nconsole.log("total = " + total);\ndata.price = 20;\nconsole.log("total = " + total);\ndata.quantity = 10;\nconsole.log("total = " + total);\n')])])]),n("p",[e._v("Now when we re-run the program, we see the following output in the console:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("total = 10\ntotal = 40\ntotal = 200\n")])])]),n("p",[e._v("That’s a good sign. The total updates when we update the price and quantity.")]),e._v(" "),n("p",[e._v("Adding Reactive Properties\nNow we should be able to add properties into data without declaring them upfront. That was one of the reasons for considering proxies over getters/setters right? Let’s try it out.")]),e._v(" "),n("p",[e._v("We can add the following code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('deps.set("discount", new Dep());  // Need a new dep for our property\ndata["discount"] = 5; // Add our new property\n\nlet salePrice = 0; \n\nwatcher(() => {  // New code to watch which includes our reactive property\n  salePrice = data.price - data.discount;\n});\n\nconsole.log("salePrice = " + salePrice);\ndata.discount = 7.5;  // This should be reactive, and rerun the watcher.\nconsole.log("salePrice = " + salePrice);\n')])])]),n("p",[e._v("When the program is run we can see the following output:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("....\nsalePrice = 15\nsalePrice = 12.5\n")])])]),n("p",[e._v("You can see that when the data.discount is modified the salePrice also gets updated. Hurray! The finished code can be seen here.")]),e._v(" "),n("p",[e._v("ReVue\nIn this lesson Evan You spoke to us about how future versions of Vue (v2.6-next) could implement reactivity using Proxies. We learned more about:")]),e._v(" "),n("p",[e._v("The limitations of current reactivity system\nHow proxies work\nHow to build a reactivity system using proxies\nIn the next video, we’ll dive into the Vue source code and discover where reactivity lies.")])])}),[],!1,null,null,null);t.default=o.exports}}]);