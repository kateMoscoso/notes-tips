(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{369:function(e,t,o){"use strict";o.r(t);var a=o(43),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("Computed Values & Vue 3 Source\nAs we’ve been building out our Reactivity example, you may have been wondering “why haven’t we used computed for our values where we’ve been using effect?” When looking at our example:")]),e._v(" "),o("p",[e._v("let product = reactive({ price: 5, quantity: 2 })\nlet salePrice = ref(0)\nlet total = 0\neffect(() => {\nsalePrice.value = product.price * 0.9\n})\neffect(() => {\ntotal = salePrice.value * product.quantity\n})\nIt seems clear to me that if I was coding up Vue I would write both salePrice and total as computed properties. If you’re familiar with the Vue 3 composition API, you’re probably familiar with the computed syntax. If you’re not, maybe take our Vue 3 Essentials course. We might use the computed syntax like so (even though we haven’t defined it yet):")]),e._v(" "),o("p",[e._v("let product = reactive({ price: 5, quantity: 2 })")]),e._v(" "),o("p",[e._v("let salePrice = computed(() => {\nreturn product.price * 0.9\n})\nlet total = computed(() => {\nreturn salePrice.value * product.quantity\n})\nMakes sense right? And notice how my salePrice computed property is included inside my total computed property, and that we access it using .value. This is our first clue to implementation. It looks like we’re creating another reactive reference. Here’s how we create our computed function:")]),e._v(" "),o("p",[e._v("function computed(getter) {\nlet result = ref()  // Create a new reactive reference")]),e._v(" "),o("p",[e._v("effect(() => (result.value = getter())) // Set this value equal to the return value of the getter")]),e._v(" "),o("p",[e._v("return result // return the reactive reference\n}\nThat’s all there is to it. You can view / run the code in its entirety over on Github. Our code prints out:")]),e._v(" "),o("p",[e._v("Before updated quantity total (should be 9) = 9 salePrice (should be 4.5) = 4.5\nAfter updated quantity total (should be 13.5) = 13.5 salePrice (should be 4.5) = 4.5\nAfter updated price total (should be 27) = 27 salePrice (should be 9) = 9\nVue Reactivity without a Caveat\nIt’s worth mentioning that we can do something with our reactive objects that was impossible with Vue 2. Specifically, we can add new reactive properties. Like so:")]),e._v(" "),o("p",[e._v("...\nlet product = reactive({ price: 5, quantity: 2 })\n...")]),e._v(" "),o("p",[e._v("product.name = 'Shoes'\neffect(() => {\nconsole.log("),o("code",[e._v("Product name is now ${product.name}")]),e._v(")\n})\nproduct.name = 'Socks'\nAs you might expect, it prints out:")]),e._v(" "),o("p",[e._v("Product name is now Shoes\nProduct name is now Socks\nThis was impossible with Vue 2 because of how Reactivity was implemented, adding getters and setters to individual object properties using Object.defineProperty. Now with Proxy we can add new properties no problem and they’re instantly reactive.")]),e._v(" "),o("p",[e._v("Testing our code against Vue 3 Source\nYou might be wondering, would this code work against Vue 3 source? So I cloned the vue-next repo (currently alpha 5), ran yarn install, then yarn build reactivity. This gave me a bunch of files in my packages/reactivity/dist/ . I then took the reactivity.cjs.js file I found there and moved it next to my example files, the ones on github, and wrote this up to use Vue’s Reactivity code:")]),e._v(" "),o("p",[e._v("var { reactive, computed, effect } = require('./reactivity.cjs')")]),e._v(" "),o("p",[e._v("// Exactly the same code here from before, without the definitions")]),e._v(" "),o("p",[e._v("let product = reactive({ price: 5, quantity: 2 })")]),e._v(" "),o("p",[e._v("let salePrice = computed(() => {\nreturn product.price * 0.9\n})")]),e._v(" "),o("p",[e._v("let total = computed(() => {\nreturn salePrice.value * product.quantity\n})")]),e._v(" "),o("p",[e._v("console.log(\n"),o("code",[e._v("Before updated quantity total (should be 9) = ${total.value} salePrice (should be 4.5) = ${salePrice.value}")]),e._v("\n)\nproduct.quantity = 3\nconsole.log(\n"),o("code",[e._v("After updated quantity total (should be 13.5) = ${total.value} salePrice (should be 4.5) = ${salePrice.value}")]),e._v("\n)\nproduct.price = 10\nconsole.log(\n"),o("code",[e._v("After updated price total (should be 27) = ${total.value} salePrice (should be 9) = ${salePrice.value}")]),e._v("\n)\nproduct.name = 'Shoes'\neffect(() => {\nconsole.log("),o("code",[e._v("Product name is now ${product.name}")]),e._v(")\n})\nproduct.name = 'Socks'\nRan this with node 08-vue-reactivity.js, and as expected, I got all the same results!")]),e._v(" "),o("p",[e._v("Before updated quantity total (should be 9) = 9 salePrice (should be 4.5) = 4.5\nAfter updated quantity total (should be 13.5) = 13.5 salePrice (should be 4.5) = 4.5\nAfter updated price total (should be 27) = 27 salePrice (should be 9) = 9\nProduct name is now Shoes\nProduct name is now Socks\nWow, so our reactivity system works as well as Vue! Well, at a basic level … yes, but in reality Vue’s version is MUCH more complex. Let’s take a look through the files that make up Vue 3’s Reactivity system, to begin to get familiar.")]),e._v(" "),o("p",[e._v("Vue 3 Reactivity Files\nIf we take a look inside the Vue 3 source, inside /packages/reactivity/src/ we’ll find the following files. Yes they are TypeScript (ts) files, but you should be able to read them (even if you don’t know TypeScript).")]),e._v(" "),o("p",[e._v("effect.ts - Defines the effect function to encapsulate code that may contain reactive references and objects. Contains track which is called from get requests and trigger which is called from set requests.\nbaseHandlers.ts - Contains the Proxy handlers like get and set, which call track and trigger (from effect.ts).\nreactive.ts - Contains the functionality for the reactive syntax which creates an ES6 Proxy using get and set (from basehandlers.ts).\nref.ts - Defines how we create Reactive References, using object accessors (like we did). Also contains toRefs which converts reactive objects into a series of reactive references which access the original proxy.\ncomputed.ts - Defines the computed function using effect and object accessors (a little different than we did).\nThere are a few more additional files, but these carry the core functionality. If you’re feeling like a challenge, you may want to dive into the source code. In the next two lessons we’ll speak to Evan You about how he implemented Reactivity in Vue 3 and give us a tour of the source himself.")])])}),[],!1,null,null,null);t.default=n.exports}}]);