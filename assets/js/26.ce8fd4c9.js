(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{373:function(e,t,n){"use strict";n.r(t);var a=n(43),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"sharing-state"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sharing-state"}},[e._v("#")]),e._v(" Sharing State")]),e._v(" "),n("p",[e._v("Now that weâ€™ve learned the basic syntax of the Composition API, letâ€™s use it to extract some reusable code from a component. When working with API calls, quite often thereâ€™s a lot of code and functionality that we might want to build around a call. Specifically things like loading state, error state, and try / catch blocks. Letâ€™s look at this code and then extract it properly using the Composition API.")]),e._v(" "),n("p",[e._v("Iâ€™ve built out the code sample from the previous lesson:")]),e._v(" "),n("p",[e._v("ðŸ“„ /src/App.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    Search for <input v-model="searchInput" /> \n    <div>\n      <p>Loading: {{ loading }}</p>\n      <p>Error: {{ error }}</p>\n      <p>Number of events: {{ results }}</p>\n    </div>\n  </div>\n</template>\n<script>\nimport { ref, watch } from "@vue/composition-api";\nimport eventApi from "@/api/event.js";\nexport default {\n  setup() {\n    const searchInput = ref("");\n    const results = ref(null);\n    const loading = ref(false);\n    const error = ref(null);\n    async function loadData(search) {\n      loading.value = true;\n      error.value = null;\n      results.value = null;\n      try {\n        results.value = await eventApi.getEventCount(search.value);\n      } catch (err) {\n        error.value = err;\n      } finally {\n        loading.value = false;\n      }\n    }\n    watch(searchInput, () => {\n      if (searchInput.value !== "") {\n        loadData(searchInput);\n      } else {\n        results.value = null;\n      }\n    });\n    return { searchInput, results, loading, error };\n  }\n};\n<\/script>\n')])])]),n("p",[e._v("Now with Shared State\nThis is a pretty common pattern in a Vue application where I have an API call and I need to account for the results, loading, and error state. How might I extract this to use the composition API? Well first I might create a new file and extract the common functionality.")]),e._v(" "),n("p",[e._v("ðŸ“„ /composables/use-promise.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import { ref } from "@vue/composition-api";\nexport default function usePromise(fn) { // fn is the actual API call\n  const results = ref(null);\n  const loading = ref(false);\n  const error = ref(null);\n  const createPromise = async (...args) => { // Args is where we send in searchInput\n    loading.value = true;\n    error.value = null;\n    results.value = null;\n    try {\n      results.value = await fn(...args); // Passing through the SearchInput\n    } catch (err) {\n      error.value = err;\n    } finally {\n      loading.value = false;\n    }\n  };\n  return { results, loading, error, createPromise };\n}\n')])])]),n("p",[e._v("Notice how this function holds the reactive references as well as a function that wraps the API call, along with any arguments that need to be passed into the API call. Now to use this code:")]),e._v(" "),n("p",[e._v("ðŸ“„ /src/App.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    Search for <input v-model="searchInput" /> \n    <div>\n      <p>Loading: {{ getEvents.loading }}</p>\n      <p>Error: {{ getEvents.error }}</p>\n      <p>Number of events: {{ getEvents.results }}</p>\n    </div>\n  </div>\n</template>\n<script>\nimport { ref, watch } from "@vue/composition-api";\nimport eventApi from "@/api/event.js";\nimport usePromise from "@/composables/use-promise";\nexport default {\n  setup() {\n    const searchInput = ref("");\n    const getEvents = usePromise(search =>\n      eventApi.getEventCount(search.value)\n    );\n\n    watch(searchInput, () => {\n      if (searchInput.value !== "") {\n        getEvents.createPromise(searchInput);\n      } else {\n        getEvents.results.value = null;\n      }\n    });\n    return { searchInput, getEvents };\n  }\n};\n<\/script>\n')])])]),n("p",[e._v("Thatâ€™s all there is to it, and we get the same functionality shown above.")]),e._v(" "),n("p",[e._v("Notice in particular how easy it is to have reactive state (loading, error, and results) that lives inside my use-promise.js file which gets used inside my component. Now when I have another API call I can use-promise.")]),e._v(" "),n("p",[e._v("Caveat\nWhen I ran this by members of the Vue core team, they called attention to â€¦getEvents. Specifically that I shouldnâ€™t be destructuring the object. Without destructuring the data is namespaced under getEvents which makes it more encapsulated and clear where the data is coming from in the component using it. It might look like:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    Search for <input v-model="searchInput" /> \n    <div>\n      <p>Loading: {{ getEvents.loading }}</p>\n      <p>Error: {{ getEvents.error }}</p>\n      <p>Number of events: {{ getEvents.results }}</p>\n    </div>\n  </div>\n</template>\n<script>\n...\nexport default {\n  setup() {\n    ...\n    return { searchInput, getEvents };\n  }\n};\n<\/script>\n')])])]),n("p",[e._v("It looks like Vue 2 with the composition API isnâ€™t properly recognizing my Reactive References and calling .value like it should. I could fix this by adding .value manually orr by actually using Vue 3. I tested the code with Vue 3 and sure enough, it saw the Reactive References and properly displayed the .value.")])])}),[],!1,null,null,null);t.default=s.exports}}]);