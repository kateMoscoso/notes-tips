(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{368:function(e,t,a){"use strict";a.r(t);var n=a(43),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("activeEffect & ref\nIn this lesson we‚Äôll continue to build out our reactivity code by fixing a small bug and then implementing reactive references, much like you might have seen in Vue 3. The bottom of our current code from the last lesson looks like this:")]),e._v(" "),a("p",[e._v("...\nlet product = reactive({ price: 5, quantity: 2 })\nlet total = 0")]),e._v(" "),a("p",[e._v("let effect = () => {\ntotal = product.price * product.quantity\n}\neffect()")]),e._v(" "),a("p",[e._v("console.log(total)")]),e._v(" "),a("p",[e._v("product.quantity = 3")]),e._v(" "),a("p",[e._v("console.log(total)\nThe problem arrives when we add code which GETs a property from our reactive object, like so:")]),e._v(" "),a("p",[e._v("console.log('Updated quantity to = ' + product.quantity)\nThe issue here is that track and all of it‚Äôs function will get called, even if we‚Äôre not inside an effect. We only want to look up and record the effect if get is called inside the active effect.")]),e._v(" "),a("p",[e._v("Solution: activeEffect\nTo solve this problem, we‚Äôll first create an activeEffect, a global variable we‚Äôll store the currently running effect in. We‚Äôll then set this inside a new function called effect.")]),e._v(" "),a("p",[e._v("let activeEffect = null // The active effect running\n...\nfunction effect(eff) {\nactiveEffect = eff  // Set this as the activeEffect\nactiveEffect()      // Run it\nactiveEffect = null // Unset it\n}")]),e._v(" "),a("p",[e._v("let product = reactive({ price: 5, quantity: 2 })\nlet total = 0")]),e._v(" "),a("p",[e._v("effect(() => {\ntotal = product.price * product.quantity\n})")]),e._v(" "),a("p",[e._v("effect(() => {\nsalePrice = product.price * 0.9\n})")]),e._v(" "),a("p",[e._v("console.log(\n"),a("code",[e._v("Before updated total (should be 10) = ${total} salePrice (should be 4.5) = ${salePrice}")]),e._v("\n)")]),e._v(" "),a("p",[e._v("product.quantity = 3")]),e._v(" "),a("p",[e._v("console.log(\n"),a("code",[e._v("After updated total (should be 15) = ${total} salePrice (should be 4.5) = ${salePrice}")]),e._v("\n)")]),e._v(" "),a("p",[e._v("product.price = 10")]),e._v(" "),a("p",[e._v("console.log(\n"),a("code",[e._v("After updated total (should be 30) = ${total} salePrice (should be 9) = ${salePrice}")]),e._v("\n)\nNotice that we no longer need to call the effect manually. It‚Äôs getting called automatically inside our new effect function. Notice I‚Äôve also added a second effect, because why not üòÅ. I‚Äôve also updated our console.logs to look more like tests, so we can verify the proper output. You can try out all the code yourself by grabbing it off github.")]),e._v(" "),a("p",[e._v("So good so far, but there‚Äôs one more change we need to make, and that‚Äôs inside the track function. It needs to use our new activeEffect.")]),e._v(" "),a("p",[e._v("function track(target, key) {\nif (activeEffect) { // <------ Check to see if we have an activeEffect\nlet depsMap = targetMap.get(target)\nif (!depsMap) {\ntargetMap.set(target, (depsMap = new Map()))\n}\nlet dep = depsMap.get(key)\nif (!dep) {\ndepsMap.set(key, (dep = new Set())) // Create a new Set\n}\ndep.add(activeEffect) // <----- Add activeEffect to dependency map\n}\n}\nGreat, now if we run our code we properly get:")]),e._v(" "),a("p",[e._v("Before updated total (should be 10) = 10 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 15) = 15 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 30) = 30 salePrice (should be 9) = 9\nIf you want to walk through this code executing line by line, definitely check out the video.")]),e._v(" "),a("p",[e._v("The Need for Ref\nWhen I was coding up this challenge I realized that the way I was calculating total might make a little more sense if it used the salePrice rather than price, like so:")]),e._v(" "),a("p",[e._v("effect(() => {\ntotal = salePrice * product.quantity\n})\nIf we were creating a real store, we‚Äôd probably calculate the total based on the salePrice. However, this code wouldn‚Äôt work reactively. Specifically, when product.price is updated, it will reactively recalculate the salePrice with this effect:")]),e._v(" "),a("p",[e._v("effect(() => {\nsalePrice = product.price * 0.9\n})\nBut since salePrice isn‚Äôt reactive, the effect with total won‚Äôt get recalculated. Our first effect above won‚Äôt get re-run. We need some way to make salePrice reactive, and it‚Äôd be nice if we didn‚Äôt have to wrap it in another reactive object. If you‚Äôre familiar with the Composition API, which I teach in the Vue 3 Essentials Course, you might be thinking that I should use ref to create a Reactive Reference. Let‚Äôs do this:")]),e._v(" "),a("p",[e._v("let product = reactive({ price: 5, quantity: 2 })\nlet salePrice = ref(0)\nlet total = 0\nAccording to the Vue documentation, a reactive reference takes an inner value and returns a reactive and mutable ref object. The ref object has a single property .value that points to the inner value. So we‚Äôd need to change around our effects a little to use .value.")]),e._v(" "),a("p",[e._v("effect(() => {\ntotal = salePrice.value * product.quantity\n})")]),e._v(" "),a("p",[e._v("effect(() => {\nsalePrice.value = product.price * 0.9\n})\nOur code should work now, properly updating the total when salePrice is updated. However, we still need to define ref. There‚Äôs two ways we could do it.")]),e._v(" "),a("ol",[a("li",[e._v("Defining Ref with Reactive\nFirst, we could simply use reactive as we‚Äôve defined it:")])]),e._v(" "),a("p",[e._v("function ref(intialValue) {\nreturn reactive({ value: initialValue })\n}\nHowever, this isn‚Äôt how Vue 3 defines ref with primitives, so let‚Äôs implement it differently.")]),e._v(" "),a("p",[e._v("Understanding JavaScript Object Accessors\nIn order to understand how Vue 3 defines ref, we first need to make sure we are familiar with object accessors. These are sometimes also known as JavaScript computed properties (not to be confused with Vue computed properties). Below you can see a simple example which uses Object Accessors:")]),e._v(" "),a("p",[e._v("let user = {\nfirstName: 'Gregg',\nlastName: 'Pollack',")]),e._v(" "),a("p",[e._v("get fullName() {\nreturn "),a("code",[e._v("${this.firstName} ${this.lastName}")]),e._v("\n},")]),e._v(" "),a("p",[e._v("set fullName(value) {\n[this.firstName, this.lastName] = value.split(' ')\n},\n}")]),e._v(" "),a("p",[e._v("console.log("),a("code",[e._v("Name is ${user.fullName}")]),e._v(")\nuser.fullName = 'Adam Jahr'\nconsole.log("),a("code",[e._v("Name is ${user.fullName}")]),e._v(")\nThe get and set lines are object accessors to get fullName and set fullName accordingly. This is plain JavaScript, and is not a feature of Vue.")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("Defining Ref with Object Accessors\nUsing Object Accessors, along with our track and trigger actions, we can now define ref using:")])]),e._v(" "),a("p",[e._v("function ref(raw) {\nconst r = {\nget value() {\ntrack(r, 'value')\nreturn raw\n},\nset value(newVal) {\nraw = newVal\ntrigger(r, 'value')\n},\n}\nreturn r\n}\nThat‚Äôs all there is to it. Now when we run the following code:")]),e._v(" "),a("p",[e._v("...\nfunction ref(raw) {\nconst r = {\nget value() {\ntrack(r, 'value')\nreturn raw\n},\nset value(newVal) {\nraw = newVal\ntrigger(r, 'value')\n},\n}\nreturn r\n}")]),e._v(" "),a("p",[e._v("function effect(eff) {\nactiveEffect = eff\nactiveEffect()\nactiveEffect = null\n}")]),e._v(" "),a("p",[e._v("let product = reactive({ price: 5, quantity: 2 })\nlet salePrice = ref(0)\nlet total = 0")]),e._v(" "),a("p",[e._v("effect(() => {\ntotal = salePrice.value * product.quantity\n})")]),e._v(" "),a("p",[e._v("effect(() => {\nsalePrice.value = product.price * 0.9\n})")]),e._v(" "),a("p",[e._v("console.log(\n"),a("code",[e._v("Before updated quantity total (should be 9) = ${total} salePrice (should be 4.5) = ${salePrice.value}")]),e._v("\n)\nproduct.quantity = 3\nconsole.log(\n"),a("code",[e._v("After updated quantity total (should be 13.5) = ${total} salePrice (should be 4.5) = ${salePrice.value}")]),e._v("\n)\nproduct.price = 10\nconsole.log(\n"),a("code",[e._v("After updated price total (should be 27) = ${total} salePrice (should be 9) = ${salePrice.value}")]),e._v("\n)\nWe get what we would expect:")]),e._v(" "),a("p",[e._v("Before updated total (should be 10) = 10 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 13.5) = 13.5 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 27) = 27 salePrice (should be 9) = 9\nOur salePrice is now reactive and total gets updated when it changes!")])])}),[],!1,null,null,null);t.default=o.exports}}]);