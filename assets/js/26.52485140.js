(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{226:function(e,t,n){"use strict";n.r(t);var a=n(0),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Limitation Vue 2")]),e._v(" "),n("ul",[n("li",[e._v("Readability as components grow")]),e._v(" "),n("li",[e._v("Code reuse patterns have drawbacks")]),e._v(" "),n("li",[e._v("Limited TypeScript Support")]),e._v(" "),n("li",[e._v("No perfect way to reuse logic between components:\n"),n("ul",[n("li",[e._v("Mixins\n"),n("ul",[n("li",[e._v("✔ Organized by feature")]),e._v(" "),n("li",[e._v("❕conflict prone")]),e._v(" "),n("li",[e._v("❕unclear relationships")]),e._v(" "),n("li",[e._v("❕Not easily reusable")])])]),e._v(" "),n("li",[e._v("Mixins factories: Functions that return a customized version of a mixin\n"),n("ul",[n("li",[e._v("✔ Easily Reusable")]),e._v(" "),n("li",[e._v("✔ Clearer relationships")]),e._v(" "),n("li",[e._v("❕weak namespacing")]),e._v(" "),n("li",[e._v("❕Implicit property additions")]),e._v(" "),n("li",[e._v("❕No instance access at runtime")])])]),e._v(" "),n("li",[e._v("Scoped Slots")]),e._v(" "),n("li",[e._v("✔ Solves Mixin Problems")]),e._v(" "),n("li",[e._v("❕Increases identantion")]),e._v(" "),n("li",[e._v("❕Lots fo configuration")]),e._v(" "),n("li",[e._v("❕Less flexible")]),e._v(" "),n("li",[e._v("❕Less performant")])])])]),e._v(" "),n("h2",{attrs:{id:"composition-functions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#composition-functions"}},[e._v("#")]),e._v(" Composition functions:")]),e._v(" "),n("p",[e._v("The good")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("We’re writing less code, so it’s easier to pull a feature from your component into a function.")])]),e._v(" "),n("li",[n("p",[e._v("It builds on your existing skills since you’re already familiar with functions.")])]),e._v(" "),n("li",[n("p",[e._v("It’s more flexible than Mixins and Scoped Slots since they’re just functions.")])]),e._v(" "),n("li",[n("p",[e._v("Intellisense, autocomplete, and typings already work in your code editor.\nThe not so good")])]),e._v(" "),n("li",[n("p",[e._v("Requires learning a new low-level API to define composition functions.")])]),e._v(" "),n("li",[n("p",[e._v("There are now two ways to write components instead of just the standard syntax.")])])]),e._v(" "),n("p",[e._v("vu3")]),e._v(" "),n("ul",[n("li",[e._v("Code can now be organized by logicall concerns - This doesn't mean tht our user interface now has less components")]),e._v(" "),n("li")]),e._v(" "),n("p",[e._v("When to use new Composition API Syntex")]),e._v(" "),n("ul",[n("li",[e._v("TypeScript support")]),e._v(" "),n("li",[e._v("Component is too large and needs to be organized by feature")]),e._v(" "),n("li",[e._v("Need to reuse code acreoss other components")])]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("setup")]),e._v(" executes before any of the following options are evaluated:")]),e._v(" "),n("ul",[n("li",[e._v("Components")]),e._v(" "),n("li",[e._v("Props")]),e._v(" "),n("li",[e._v("Data")]),e._v(" "),n("li",[e._v("Methods")]),e._v(" "),n("li",[e._v("Computed Properties")]),e._v(" "),n("li",[e._v("Lifecycle methods")])]),e._v(" "),n("p",[e._v("It’s also worth mentioning that the setup method does not have access “this”, unlike other Component options. In order to get access to the properties we normally would access using this, "),n("code",[e._v("setup")]),e._v(" has two optional arguments. The first is props which is reactive and can be watched, as such:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import { watch } from "vue";\nexport default {\n  props: {\n    name: String\n  },\n  setup(props) {\n    watch(() => {\n      console.log(props.name);\n    });\n  }\n};\n')])])]),n("p",[e._v("The second argument is context, that has access to a bunch of useful data:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("setup(props, context) {\n  context.attrs;\n  context.slots;\n  context.parent;\n  context.root;\n  context.emit;\n}\n")])])]),n("h3",{attrs:{id:"reactive-references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactive-references"}},[e._v("#")]),e._v(" Reactive References")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n <div>Capacity: {{ capacity }}</div>\n</template>\n<script>\nimport { ref } from "vue";\nexport default {\n  setup() {\n    const capacity = ref(3);\n    // additional code to write\n  }\n};\n<\/script>\n')])])]),n("p",[n("code",[e._v("const capacity = ref(3)")]),e._v(" is creating a “Reactive Reference.” Basically it’s wrapping our primitive integer (3) in an object, which will allow us to track changes. Remember, previously our "),n("code",[e._v("data()")]),e._v(" option already wrapping our primitive (capacity) inside an object.")]),e._v(" "),n("p",[e._v("Aside: The composition API allows us to declare reactive primitives that aren’t associated with a component, and this is how we do it.")]),e._v(" "),n("p",[e._v("One last step, we need to explicitly return an object with properties our template will need to render properly.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>Capacity: {{ capacity }}</div>\n</template>\n<script>\nimport { ref } from "vue";\nexport default {\n  setup() {\n    const capacity = ref(3);\n    return { capacity };\n  }\n};\n<\/script>\n')])])]),n("p",[e._v("This returned object is how we expose which data we need access to in the renderContext.")]),e._v(" "),n("p",[e._v("Being explicit like this is a little more verbose, but it’s also intentional. It helps with longer-term maintainability because we can control what gets exposed to the template, and trace where a template property is defined. We now have what we started with:")]),e._v(" "),n("h3",{attrs:{id:"vue-2-and-vue-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-and-vue-3"}},[e._v("#")]),e._v(" vue 2 and vue 3")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    <p>Capacity: {{ capacity }}</p>\n    <button @click="increaseCapacity()">Increase Capacity</button>\n  </div>\n</template>\n\n<script>\nimport { ref } from "vue";\nexport default {\n  setup() {\n    const capacity = ref(3);\n\n   function increaseCapacity() { \n  capacity++;\n}\n    return { capacity, increaseCapacity };\n  }\n};\n<\/script>\n')])])]),n("p",[e._v("Example")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <div>\n    <p>Spaces Left: {{ spacesLeft }} out of {{ capacity }}</p>\n    <h2>Attending</h2>\n    <ul>\n      <li v-for="(name, index) in attending" :key="index">\n        {{ name }}\n      </li>\n    </ul>\n    <button @click="increaseCapacity()">Increase Capacity</button>\n  </div>\n</template>\n<script>\nimport { ref, computed } from "vue";\nexport default {\n  setup() {\n    const capacity = ref(4);\n    const attending = ref(["Tim", "Bob", "Joe"]);\n\n    const spacesLeft = computed(() => { // <-------\n      return capacity.value - attending.value.length;\n    });\n\n    function increaseCapacity() {\n      capacity.value++;\n    }\n    return { capacity, attending, spacesLeft, increaseCapacity };\n  }\n};\n<\/script>\n')])])]),n("h3",{attrs:{id:"introducing-torefs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#introducing-torefs"}},[e._v("#")]),e._v(" Introducing toRefs")]),e._v(" "),n("p",[e._v("This method converts a reactive object to a plain object, where each property is a Reactive Reference pointing to the property on the original object. Here is our completed code using this method:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('    import { reactive, computed, toRefs } from "vue";\n    export default {\n      setup() {\n        const event = reactive({\n          capacity: 4,\n          attending: ["Tim", "Bob", "Joe"],\n          spacesLeft: computed(() => {\n            return event.capacity - event.attending.length;\n          })\n        });\n        function increaseCapacity() {\n          event.capacity++;\n        }\n        return { ...toRefs(event), increaseCapacity };\n      }\n    };\n')])])]),n("p",[e._v("Notice that I’m importing toRefs and then using it in my return statement, and then destructuring the object. This works great!")]),e._v(" "),n("h3",{attrs:{id:"modularizing"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#modularizing"}},[e._v("#")]),e._v(" Modularizing")]),e._v(" "),n("p",[e._v("use/event-space.vue")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('    import { ref, computed } from "vue";\n    \n    export default function useEventSpace() {\n      const capacity = ref(4);\n      const attending = ref(["Tim", "Bob", "Joe"]);\n      const spacesLeft = computed(() => {\n        return capacity.value - attending.value.length;\n      });\n      function increaseCapacity() {\n        capacity.value++;\n      }\n      return { capacity, attending, spacesLeft, increaseCapacity };\n    }\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('    <template>\n      ...\n    </template>\n    <script>\n    import useEventSpace from "@/use/event-space";\n    import useMapping from "@/use/mapping";\n    export default {\n      setup() {\n        return { ...useEventSpace(), ...useMapping() }\n      }\n    };\n    <\/script>\n')])])])])}),[],!1,null,null,null);t.default=i.exports}}]);